#1 Segment Tree
- A segment tree is a data structure that allows the storage of array intervals in the form of a tree. It efficiently handles range queries and updates by organizing data hierarchically.Subment tree is a data structure that allows to store array intervals as a tree.
- Although called a tree, its nodes are stored as elements in an array. The length of this array is typically <math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>4</mn><mo>×</mo><mtext>length of the original array</mtext></mrow><annotation encoding="application/x-tex"> 4 \times \text{length of the original array} </annotation></semantics></math> to accommodate all nodes (including internal nodes and extra space for any tree shape), though the theoretical minimum is <math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>2</mn><mi>n</mi><mo>−</mo><mn>1</mn></mrow><annotation encoding="application/x-tex"> 2n - 1 </annotation></semantics></math> for an array of size <math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex"> n </annotation></semantics></math>.
- The segment tree array uses 1-based indexing for convenience. The children of a node at index <math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex"> n </annotation></semantics></math> are located at indices <math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>2</mn><mi>n</mi></mrow><annotation encoding="application/x-tex"> 2n </annotation></semantics></math> (left child) and <math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>2</mn><mi>n</mi><mo>+</mo><mn>1</mn></mrow><annotation encoding="application/x-tex"> 2n + 1 </annotation></semantics></math> (right child), assuming a complete binary tree structure.

- Segment trees are highly adaptable, supporting updates to array elements (e.g., point updates) and range updates (with techniques like lazy propagation), making them suitable for dynamic data

#2 why we need the segment tree
- Comparison with Prefix Sum: In some cases, problems involving range queries (e.g., sum or minimum in a range) can be solved using a prefix sum approach. However, if the problem requires a time complexity better than <math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><msup><mi>n</mi><mn>2</mn></msup><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex"> O(n^2) </annotation></semantics></math> (e.g., for frequent updates or queries), the prefix sum approach becomes inefficient because it only supports <math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mn>1</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex"> O(1) </annotation></semantics></math> queries after <math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex"> O(n) </annotation></semantics></math> preprocessing, but updates take <math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex"> O(n) </annotation></semantics></math>.

- Segment trees enable querying the sum of consecutive array elements in a range <math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">[</mo><mi>l</mi><mi>e</mi><mi>f</mi><mi>t</mi><mo separator="true">,</mo><mi>r</mi><mi>i</mi><mi>g</mi><mi>h</mi><mi>t</mi><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">[left, right]</annotation></semantics></math> or finding the minimum (or maximum) of array elements in a specific range in <math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>log</mi><mo>⁡</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex"> O(\log n) </annotation></semantics></math> time, with point updates also in <math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>log</mi><mo>⁡</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex"> O(\log n) </annotation></semantics></math>. This is a significant improvement over naive <math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex"> O(n) </annotation></semantics></math> per query or update.

- The utility of segment trees is remarkable, with applications in competitive programming, such as range sum queries, range minimum/maximum queries, and even more complex tasks like counting inversions or managing dynamic ranges (e.g., with lazy propagation).

#3 Reference

 - [1] Foundation of segment tree: https://cp-algorithms.com/data_structures/segment_tree.html
 - [2] Great to implement segment tree with this problem: https://leetcode.com/problems/range-sum-query-mutable/description/
 - [3] Vietnamese video of segment tree tutorial: https://www.youtube.com/watch?v=27zXJOmns1M&t=677s
 - [4] Comparison between `Prefix sum` and `Segment Tree`